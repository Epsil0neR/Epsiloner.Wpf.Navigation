using System;
using System.ComponentModel;
using System.Linq;
using System.Windows;
using System.Windows.Threading;

namespace Epsiloner.Wpf.Navigation
{
    internal class ShellState : IDisposable
    {
        /// <summary>
        /// Indicates that shell is closed.
        /// </summary>
        internal event EventHandler ShellClosed;

        internal ShellState(ShellBase shell)
        {
            Shell = shell;

            Shell.Closing += ShellOnClosing;
            Shell.Closed += ShellOnClosed;
        }

        /// <summary>
        /// Indicated if currently shell state has data.
        /// </summary>
        internal bool IsLoaded { get; private set; }

        internal ShellBase Shell { get; }

        /// <summary>
        /// Currently used navigation mode in <see cref="Shell"/>.
        /// </summary>
        internal NavigationMode Mode { get; private set; }

        /// <summary>
        /// Currently used navigation config in <see cref="Shell"/>.
        /// </summary>
        internal INavigationConfig<INavigationTarget> Config { get; private set; }

        /// <summary>
        /// Current navigation target in <see cref="Shell"/>.
        /// </summary>
        internal INavigationTarget Target { get; private set; }

        /// <summary>
        /// Data generated by <see cref="Config"/> for <see cref="Target"/> and used in <see cref="Shell"/>.
        /// </summary>
        internal object Data { get; private set; }

        /// <summary>
        /// View used in <see cref="Shell"/> for <see cref="Data"/>.
        /// </summary>
        internal INavigatableView View { get; private set; }

        /// <summary>
        /// Unloads data from <see cref="Shell"/>.
        /// </summary>
        internal void Unload()
        {
            if (Shell.Dispatcher.CheckAccess())
                UnloadAction();
            else
                Shell.Dispatcher.Invoke(UnloadAction);
        }

        private void UnloadAction()
        {
            UnloadView();
            View = Shell.SetContent(null, null);
            (Data as IDisposable)?.Dispose();
            Data = null;

            var navigatable = Data as INavigatable;
            if (navigatable != null)
                navigatable.RequestClose -= NavigatableOnRequestClose;

            try
            {
                Shell.Owner = null;
            }
            catch (Exception) { }
            IsLoaded = false;
        }

        private void NavigatableOnRequestClose(object sender, EventArgs e)
        {
            if (Config.BlockWindowClose)
                return;

            Shell.Close();
        }

        /// <summary>
        /// Loads data to <see cref="Shell"/> and keeps data used for navigation in <see cref="Shell"/>.
        /// </summary>
        /// <param name="navMode">Navigation mode</param>
        /// <param name="config">Navigation config</param>
        /// <param name="target">Navigation target</param>
        /// <param name="data">Data for <see cref="Shell"/></param>
        internal void Load(NavigationMode navMode, INavigationConfig<INavigationTarget> config, INavigationTarget target, object data)
        {
            Mode = navMode;
            Config = config;
            Target = target;
            Data = data;
            var navigatable = Data as INavigatable;
            if (navigatable != null)
                navigatable.RequestClose += NavigatableOnRequestClose;

            UnloadView();
            View = Shell.SetContent(data, target?.GetType());
            IsLoaded = true;
        }

        /// <summary>
        /// Notifies <see cref="Data"/> and <see cref="View"/> about navigation completion.
        /// </summary>
        /// <param name="parent"></param>
        internal void NavigationCompleted(ShellBase parent)
        {
            (Data as INavigatable)?.Navigated();

            if (View != null)
                Shell.Dispatcher.Invoke(() => View.Navigated(Shell, parent));
        }

        internal void UnloadView()
        {
            View?.Unloading(Shell);
        }

        /// <summary>
        /// Default handler for shell to prevent window closing if <see cref="Config"/> does not allow close window.
        /// </summary>
        private void ShellOnClosing(object sender, CancelEventArgs args)
        {
            if (!IsLoaded)
                return;

            if (Config.BlockWindowClose)
            {
                args.Cancel = true;
                return;
            }

            RaiseShellClosed();
        }

        /// <summary>
        /// When window closes - navigation unloads.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="eventArgs"></param>
        private void ShellOnClosed(object sender, EventArgs eventArgs)
        {
            Unload();
        }

        private void RaiseShellClosed()
        {
            ShellClosed?.Invoke(this, EventArgs.Empty);
        }

        public void Dispose()
        {
            Unload();

            var app = Application.Current;

            if (app.Dispatcher.Invoke(() => app.Windows.OfType<ShellBase>().Any(x => ReferenceEquals(x, Shell))))
            {
                Shell.Dispatcher.InvokeAsync(Shell.Close, DispatcherPriority.Background);
            }

            Shell.Closing -= ShellOnClosing;
            Shell.Closed -= ShellOnClosed;
        }
    }
}